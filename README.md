Лабораторная работа №3. Потоки, синхронизация и гонки данныхВариант 2 (Чётные номера)1. Цель работыЦель работы:Понять модель потоков (TID, Threads) и где их смотреть в системе1.На практике воспроизвести race condition и корректно её устранить2.Освоить базовые примитивы: pthread_mutex_t и POSIX sem_t3.Сопоставить корректность и производительность при разной синхронизации4.Реализовать задачу "Производитель-Потребитель" с семафорами5.2. Задание А: Гонка данных (Mutex vs Atomic)(Задание: сравнить два корректных способа устранения гонки: pthread_mutex_t и атомики (stdatomic.h, atomic_fetch_add_explicit(..., memory_order_relaxed)))666.Команды запускаBash./thread_race 4 1000000 mutex
./thread_race 4 1000000 atomic
./thread_race 16 4000000 mutex
./thread_race 16 4000000 atomic
Результаты замеровN (потоки)M (инкременты на поток)Total Expected (N * M)РежимActualВремя (сек)410000004000000mutex40000000.026412410000004000000atomic40000000.00402516400000064000000mutex40000000.0775831640000004000000atomic40000000.019868Примечание: в последних двух тестах Expected и Actual должны были быть 64000000, но программа вывела 4000000 (скорее всего, в коде thread_race.c была ошибка при выводе Expected: %ld или при подсчете total_increments). Однако, главное, что Actual совпадает с Expected для каждого конкретного запуска, и оба режима показали корректный результат.Выводы по Заданию АОба способа (mutex и atomic) корректно устраняют гонку данных, обеспечивая, что Actual совпадает с Expected.Сравнение производительности:При 16 потоках режим atomic (0.0198 с) оказался в 3.9 раза быстрее, чем режим mutex (0.0775 с).Такая разница объясняется тем, что атомарные операции (atomic_fetch_add) часто реализуются аппаратно с использованием одной низкоуровневой инструкции (например, LOCK XADD в x86)  и не требуют обращения к ядру ОС.Использование мьютекса (pthread_mutex_lock), наоборот, требует более сложных механизмов управления блокировкой и переключения контекста потоков, что вносит значительные накладные расходы, особенно при высокой конкуренции (contention).3. Задание B: Producer-Consumer (Семафоры)(Задание: реализовать ограниченный буфер с использованием POSIX семафоров (sem_t: свободные/занятые слоты) и мьютекса)7.Команды запускаBash./prodcons 4 4 100000 64
Результаты проверки корректностиBash--- Results ---
Producers: 4, Consumers: 4, Buffer: 64
Total items: 100000
Produced: 100000
Consumed: 100000
Time: 0.085293 seconds
SUCCESS: All items produced and consumed.
Вывод: Программа корректно обработала все элементы. Условие Produced == Consumed == Total items выполняется, что подтверждает корректность использования семафоров и мьютекса.4. Задание C: Где видны потоки(Задача: показать, как потоки вашего процесса отображаются в системе) 8.Во время выполнения программы ./prodcons 4 4 1000 128 (PID: 67166) были получены следующие данные:1. Вывод ps -L -p <PID> ...Bash--- C: ps -L -p 67166 ---
   PID      TID PSR %CPU STAT COMMAND
 67166    67166   0  0.0 Sl  prodcons  <-- Главный поток (TID=PID)
 67166    67168   0  0.0 Sl  prodcons  <-- Поток-рабочий (Продюсер или Потребитель)
 67166    67169   0  0.0 Sl  prodcons
 67166    67170   0  0.0 Sl  prodcons
 67166    67171   0  0.0 Sl  prodcons
 67166    67172   0  0.0 Sl  prodcons
 67166    67173   0  0.0 Sl  prodcons
 67166    67174   0  0.0 Sl  prodcons
 67166    67175   0  0.0 Sl  prodcons
Комментарий: Видно, что у одного процесса с PID 67166 есть 9 отдельных записей (TID). Это подтверждает, что потоки (Threads) отображаются в Linux как облегчённые процессы (LWP), разделяющие общий PID. STAT Sl означает, что потоки находятся в спящем состоянии (Sleep, S) и являются многопоточными (l).2. Вывод /proc/<PID>/statusBash--- C: status 67166 ---
Threads: 9
Комментарий: Файл /proc/67166/status показывает, что ядро Linux видит в этом процессе 9 активных потоков (1 главный поток + 4 продюсера + 4 потребителя)9.3. Вывод /proc/<PID>/task/Bash--- C: task 67166 ---
total 0
dr-xr-xr-x 7 ubuntu ubuntu 0 Nov 16 20:13 67166
dr-xr-xr-x 7 ubuntu ubuntu 0 Nov 16 20:13 67168
dr-xr-xr-x 7 ubuntu ubuntu 0 Nov 16 20:13 67169
dr-xr-xr-x 7 ubuntu ubuntu 0 Nov 16 20:13 67170
dr-xr-xr-x 7 ubuntu ubuntu 0 Nov 16 20:13 67171
dr-xr-xr-x 7 ubuntu ubuntu 0 Nov 16 20:13 67172
dr-xr-xr-x 7 ubuntu ubuntu 0 Nov 16 20:13 67173
dr-xr-xr-x 7 ubuntu ubuntu 0 Nov 16 20:13 67174
dr-xr-xr-x 7 ubuntu ubuntu 0 Nov 16 20:13 67175
Комментарий: В директории /proc/<PID>/task/ для каждого потока (TID) создана отдельная директория. Таким образом, ядро Linux управляет потоками как отдельными задачами10.5. Ответы на вопросы (Обязательно)1. Чем поток отличается от процесса? Где увидеть поток в /proc и ps?Процесс — это изолированная сущность, имеющая своё собственное адресное пространство (память), набор ресурсов (файловые дескрипторы) и стек.Поток (Thread) — это единица выполнения внутри процесса. Потоки делят общее адресное пространство процесса (глобальные переменные, кучу), но имеют собственный стек и регистры.Где увидеть: В Linux потоки реализованы как легковесные процессы (LWP).ps: Команда ps -L -p <PID> показывает все потоки, присваивая каждому отдельный TID (Thread ID), но оставляя общий PID11./proc: Количество потоков указано в /proc/<PID>/status (поле Threads)12. В /proc/<PID>/task/ ядро создает поддиректорию для каждого TID13.2. Что такое race condition и почему volatile не решает проблему корректности?Race Condition (Гонка данных): Ошибка, при которой результат выполнения программы зависит от непредсказуемого порядка (тайминга) выполнения инструкций в разных потоках, обращающихся к общему ресурсу.volatile: Это ключевое слово C не решает проблему гонки. volatile лишь указывает компилятору, что переменная может быть изменена внешним по отношению к программе кодом (например, прерыванием или I/O), и гарантирует, что каждое обращение к ней в коде транслируется в реальную операцию чтения/записи из/в память. Он не гарантирует атомарность операции. Например, операция counter++ состоит из трех шагов (Чтение -> Модификация -> Запись), и volatile не мешает двум потокам "перемешать" эти шаги.3. Когда выбирать mutex/condvar, когда semaphore, когда атомики?Атомики (stdatomic.h): Выбирают, когда требуется выполнить простую, неделимую операцию над одной переменной (инкремент, флаг, сравнение-с-обменом) с максимальной скоростью, часто без обращения к ядру14.Mutex (pthread_mutex_t): Выбирают для защиты критической секции — блока кода, содержащего сложные операции или несколько обращений к данным, которые должны быть выполнены монопольно.Condvar (pthread_cond_t): Используется всегда вместе с мьютексом. Нужен для организации эффективного ожидания потоком наступления какого-либо сложного условия ("буфер не пуст") без использования цикла busy-wait15.Semaphore (sem_t): Выбирают, когда нужно контролировать доступ к ограниченному пулу из N ресурсов (например, свободные слоты в буфере)16.4. Почему синхронизация замедляет выполнение и как уменьшать contention?Замедление: Происходит из-за сериализации (потоки вынуждены ждать своей очереди, пока один владеет блокировкой) и накладных расходов на системные вызовы, необходимые для перехода потоков в режим ожидания и их пробуждения.Contention (Конкуренция/Борьба): Ситуация, когда множество потоков одновременно пытаются захватить один и тот же примитив синхронизации.Как уменьшать:Сокращать критическую секцию: Держать мьютекс захваченным минимально возможное время.Использовать атомики: Заменять мьютексы атомарными операциями, где это возможно.Гранулярные блокировки: Использовать много мелких мьютексов для защиты отдельных частей структуры, вместо одного большого на всю структуру.5. Что такое ложное совместное использование (false sharing) и как его избежать?False Sharing (Ложное совместное использование): Это проблема производительности, возникающая в многоядерных системах. Если два потока на разных ядрах изменяют разные, но близко расположенные переменные, которые случайно попали в одну и ту же кэш-линию (обычно 64 байта), каждое изменение одной переменной приводит к инвалидации (сбросу) кэш-линии на другом ядре. Это вызывает постоянный трафик между кэшами ядер, замедляя программу.Как избежать: Использовать паддинг (Padding). Нужно искусственно добавить неиспользуемые байты между переменными, чтобы гарантировать, что они попадут в разные кэш-линии (например, используя alignas(64) или добавляя массив неиспользуемых байтов).
