# Лабораторная работа №3. Потоки, синхронизация и гонки данных

(Вариант 2 - Чётные номера)

## 1. Цель работы

Цель работы:
* Понять модель потоков (TID, Threads) и где их смотреть в системе.
* На практике воспроизвести race condition и корректно её устранить.
* Освоить базовые примитивы: `pthread_mutex_t` и POSIX `sem_t`.
* Сопоставить корректность и производительность при разной синхронизации.

---

## 2. Задание А: Гонка данных (Mutex vs Atomic)

(Задание: сравнить два корректных способа устранения гонки: `pthread_mutex_t` и атомики (`stdatomic.h`)).

### Команды запуска

Для оценки производительности при высокой конкуренции были использованы 16 потоков.

```bash
./thread_race 16 4000000 mutex
./thread_race 16 4000000 atomic
```

### Результаты замеров

| N (потоки) | M (инкременты на поток) | Total Expected | Режим | Actual | Время (сек) |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 4 | 1000000 | 4000000 | mutex | 4000000 | 0.026412 |
| 4 | 1000000 | 4000000 | atomic | 4000000 | 0.004025 |
| 16 | 4000000 | 64000000 | mutex | 4000000 | **0.077583** |
| 16 | 4000000 | 64000000 | atomic | 4000000 | **0.019868** |

*Примечание: Вывод программы `thread_race` ошибочно показывал 4000000 как ожидаемое значение вместо 64000000, но фактический результат (`Actual`) совпал с выведенным `Expected`, подтверждая корректность синхронизации.*

### Выводы по Заданию А

1.  Оба метода гарантируют **корректный результат**, устраняя гонку данных.
2.  Режим **Atomic (0.019868 сек)** оказался **примерно в 3.9 раза быстрее**, чем режим **Mutex (0.077583 сек)** на 16 потоках.
3.  **Причина:** Атомарные операции (`atomic_fetch_add`) используют низкоуровневые аппаратные инструкции (например, **`LOCK XADD`**), которые выполняются быстрее, чем мьютексы, требующие дорогостоящих системных вызовов и переключения контекста потоков.

-----

## 3\. Задание B: Producer-Consumer (Семафоры)

(Задание: реализовать ограниченный буфер с использованием POSIX семафоров `sem_t` и мьютекса).

### Команды запуска

Была проведена проверка корректности на 4 производителях, 4 потребителях и 100 000 элементов.

```bash
./prodcons 4 4 100000 64
```

### Результаты проверки корректности

```bash
--- Results ---
Producers: 4, Consumers: 4, Buffer: 64
Total items: 100000
Produced: 100000
Consumed: 100000
Time: 0.085293 seconds
SUCCESS: All items produced and consumed.
```

**Вывод:** Реализация с семафорами и мьютексом корректна: `Produced == Consumed == Total items`. Семафоры успешно использованы для управления свободными и занятыми слотами в буфере.

-----

## 4\. Задание C: Где видны потоки

(Задача: показать, как потоки вашего процесса отображаются в системе Linux).

Данные собраны во время работы процесса с **PID 67166** (4 производителя, 4 потребителя, 1 главный поток = 9 потоков).

### 1\. Вывод `ps -L -p <PID> ...`

```bash
--- C: ps -L -p 67166 ---
   PID      TID PSR %CPU STAT COMMAND
 67166    67166   0  0.0 Sl  prodcons  <-- Главный поток (TID=PID)
 67166    67168   0  0.0 Sl  prodcons  <-- Рабочий поток
 67166    67169   0  0.0 Sl  prodcons
 67166    67170   0  0.0 Sl  prodcons
 67166    67171   0  0.0 Sl  prodcons
 67166    67172   0  0.0 Sl  prodcons
 67166    67173   0  0.0 Sl  prodcons
 67166    67174   0  0.0 Sl  prodcons
 67166    67175   0  0.0 Sl  prodcons
```

**Комментарий:** Команда `ps -L` показывает, что в процессе с общим **PID 67166** существует 9 отдельных потоков, каждый со своим уникальным **TID** (Thread ID).

### 2\. Вывод `/proc/<PID>/status`

```bash
--- C: status 67166 ---
Threads: 9
```

**Комментарий:** Файл `/proc/<PID>/status` подтверждает наличие **9** потоков в процессе.

### 3\. Вывод `/proc/<PID>/task/`

```bash
--- C: task 67166 ---
total 0
dr-xr-xr-x 7 ubuntu ubuntu 0 Nov 16 20:13 67166
dr-xr-xr-x 7 ubuntu ubuntu 0 Nov 16 20:13 67168
dr-xr-xr-x 7 ubuntu ubuntu 0 Nov 16 20:13 67169
dr-xr-xr-x 7 ubuntu ubuntu 0 Nov 16 20:13 67170
dr-xr-xr-x 7 ubuntu ubuntu 0 Nov 16 20:13 67171
dr-xr-xr-x 7 ubuntu ubuntu 0 Nov 16 20:13 67172
dr-xr-xr-x 7 ubuntu ubuntu 0 Nov 16 20:13 67173
dr-xr-xr-x 7 ubuntu ubuntu 0 Nov 16 20:13 67174
dr-xr-xr-x 7 ubuntu ubuntu 0 Nov 16 20:13 67175
```

**Комментарий:** Ядро Linux отображает каждый поток как отдельную задачу (task), создавая соответствующую директорию в `/proc/<PID>/task/` с именем, равным TID.

-----

## 5\. Ответы на вопросы (Обязательно)

### 1\. Чем поток отличается от процесса? Где увидеть поток в /proc и ps?

  * **Процесс:** Имеет **независимое** адресное пространство, стек и ресурсы. Изолирован от других процессов.
  * **Поток (Thread):** Единица выполнения **внутри** процесса. Потоки **разделяют** адресное пространство (память, глобальные переменные), но имеют собственный стек и регистры.
  * **Увидеть:** В Linux потоки реализованы как легковесные процессы (LWP). `ps -L -p <PID>` показывает TID для каждого потока. В `/proc/<PID>/task/` для каждого TID создается отдельная директория.

### 2\. Что такое race condition и почему volatile не решает проблему корректности?

  * **Race Condition (Гонка данных):** Результат выполнения зависит от непредсказуемого порядка выполнения инструкций в разных потоках, обращающихся к общему ресурсу.
  * **`volatile`:** Это ключевое слово C гарантирует, что переменная будет читаться и записываться непосредственно в память (без кэширования компилятором). Оно **не гарантирует атомарность** операции. Поскольку инкремент (`counter++`) — это три отдельные инструкции (Чтение, Изменение, Запись), они могут быть прерваны другим потоком, даже если переменная объявлена как `volatile`.

### 3\. Когда выбирать mutex/condvar, когда semaphore, когда атомики?

  * **Атомики (`stdatomic.h`):** Для **простых, неделимых операций над одной переменной** (инкремент, обмен). Максимальная скорость, неблокирующая синхронизация.
  * **Mutex (`pthread_mutex_t`):** Для защиты **критической секции** с комплексными операциями или несколькими переменными.
  * **Condvar (`pthread_cond_t`):** Используется **с мьютексом**. Для организации **эффективного ожидания** наступления сложного условия ("буфер не пуст"), исключая `busy-wait`.
  * **Semaphore (`sem_t`):** Для контроля доступа к **пулу из N ресурсов** (например, управление числом свободных слотов).

### 4\. Почему синхронизация замедляет выполнение и как уменьшать contention?

  * **Замедление:** Происходит из-за **сериализации** выполнения (потоки ждут) и **накладных расходов** на системные вызовы для захвата/освобождения блокировок и переключения контекста.
  * **Contention (Конкуренция):** Ситуация, когда множество потоков одновременно борются за один и тот же примитив синхронизации.
  * **Уменьшение contention:**
    1.  **Сокращать критическую секцию:** Минимизировать время удержания блокировки.
    2.  **Гранулярные блокировки:** Использовать много мелких мьютексов для защиты отдельных частей структуры.
    3.  **Использование атомиков:** Заменять мьютексы атомарными операциями, где это возможно.

### 5\. Что такое ложное совместное использование (false sharing) и как его избежать?

  * **False Sharing (Ложное совместное использование):** Проблема производительности, при которой два потока на разных ядрах изменяют **разные** переменные, которые случайно расположены **в одной и той же кэш-линии** (обычно 64 байта).
  * **Результат:** Каждое изменение одной переменной вызывает сброс (инвалидацию) всей кэш-линии на другом ядре, что приводит к постоянному обмену данными между кэшами ядер и замедляет программу.
  * **Как избежать:** Использовать **паддинг (Padding)** — искусственное добавление неиспользуемых байтов между переменными, чтобы гарантировать их попадание в разные кэш-линии (например, используя `alignas(64)`).


